---
title: castorsCTF20 write-ups
category: [ctf, writeup]
---

Here are my write-ups for castorsCTF20 which also happens to be THE FIRST CTF WE WIN!!!!!

![Final scoreboard](/assets/files/castorsCTF20/scoreboard.png)

### Crypto

#### Stalk Market (495 pts 18 solves)

##### Description:

```
Author: hasu

nc chals20.cybercastors.com 14423
```

A file `server.py` is attached:

```python
import socketserver
from os import urandom
from random import seed, randint
from secret import FLAG

BANNER = b"""
 ______  ______ ______  __      __  __       __    __  ______  ______  __  __  ______ ______  
/\  ___\/\__  _/\  __ \/\ \    /\ \/ /      /\ "-./  \/\  __ \/\  == \/\ \/ / /\  ___/\__  _\ 
\ \___  \/_/\ \\\ \  __ \ \ \___\ \  _"-.    \ \ \-./\ \ \  __ \ \  __<\ \  _"-\ \  __\/_/\ \/ 
 \/\_____\ \ \_\\\ \_\ \_\ \_____\ \_\ \_\    \ \_\ \ \_\ \_\ \_\ \_\ \_\ \_\ \_\ \_____\\\ \_\ 
  \/_____/  \/_/ \/_/\/_/\/_____/\/_/\/_/     \/_/  \/_/\/_/\/_/\/_/ /_/\/_/\/_/\/_____/ \/_/ 
                                                                                              """
MESSAGE = b"""
Breaking news!
The algorithm that generates turnip prices has been data mined.
All prices for the week are generated on Monday at midnight.
Understand how the algorithm works and predict prizes for
the next 20 weeks to become the Ultimate Turnip Prophet!\n
"""

sbox = [92, 74, 18, 190, 162, 125, 45, 159, 217, 153, 167, 179, 221, 151, 140, 100, 227, 83, 8, 4, 80, 75, 107, 85, 104, 216, 53, 90, 136, 133, 40, 20, 94, 32, 237, 103, 29, 175, 127, 172, 79, 5, 13, 177, 123, 128, 99, 203, 0, 198, 67, 117, 61, 152, 207, 220, 9, 232, 229, 120, 48, 246, 238, 210, 143, 7, 33, 87, 165, 111, 97, 135, 240, 113, 149, 105, 193, 130, 254, 234, 6, 76, 63, 19, 3, 206, 108, 251, 54, 102, 235, 126, 219, 228, 141, 72, 114, 161, 110, 252, 241, 231, 21, 226, 22, 194, 197, 145, 39, 192, 95, 245, 89, 91, 81, 189, 171, 122, 243, 225, 191, 78, 139, 148, 242, 43, 168, 38, 42, 112, 184, 37, 68, 244, 223, 124, 218, 101, 214, 58, 213, 34, 204, 66, 201, 180, 64, 144, 147, 255, 202, 199, 47, 196, 36, 188, 169, 186, 1, 224, 166, 10, 170, 195, 25, 71, 215, 52, 15, 142, 93, 178, 174, 182, 131, 248, 26, 14, 163, 11, 236, 205, 27, 119, 82, 70, 35, 23, 88, 154, 222, 239, 209, 208, 41, 212, 84, 176, 2, 134, 230, 51, 211, 106, 155, 185, 253, 247, 158, 56, 73, 118, 187, 250, 160, 55, 57, 16, 17, 157, 62, 65, 31, 181, 164, 121, 156, 77, 132, 200, 138, 69, 60, 50, 183, 59, 116, 28, 96, 115, 46, 24, 44, 98, 233, 137, 109, 49, 30, 173, 146, 150, 129, 12, 86, 249]
p = [8, 6, 5, 11, 14, 7, 4, 0, 9, 1, 13, 10, 2, 3, 15, 12]
round = 8

def pad(s):
    if len(s) % 16 == 0:
        return s
    else:
        pad_b = 16 - len(s) % 16
        return s + bytes([pad_b]) * pad_b

def repeated_xor(p, k):
    return bytearray([p[i] ^ k[i] for i in range(len(p))])

def group(s):
    return [s[i * 16: (i + 1) * 16] for i in range(len(s) // 16)]

def hash(data):
    state = bytearray([165, 68, 114, 228, 151, 146, 106, 238, 198, 241, 198, 122, 46, 148, 3, 38])
    data = group(pad(data))
    for roundkey in data:
        for _ in range(round):
            state = repeated_xor(state, roundkey)
            for i in range(len(state)):
                state[i] = sbox[state[i]]
            temp = bytearray(16)
            for i in range(len(state)):
                temp[p[i]] = state[i]
            state = temp
    return state.hex()

def gen_price():
    r = randint(1, 100)
    if   r >= 99: price = randint(500, 600)
    elif r >= 95: price = randint(450, 500)
    elif r >= 90: price = randint(400, 450)
    elif r >= 85: price = randint(350, 400)
    elif r >= 80: price = randint(300, 350)
    elif r >= 75: price = randint(250, 300)
    elif r >=  0: price = randint( 20, 250)
    return price

def gen_hashes_and_prices():
    d = {"mon": {"am": 0, "pm": 0},"tue": {"am": 0, "pm": 0},"wed": {"am": 0, "pm": 0},"thu": {"am": 0, "pm": 0},"fri": {"am": 0, "pm": 0},"sat": {"am": 0, "pm": 0}}
    secret = bytearray(urandom(16))
    seed(int.from_bytes(secret, 'big'))
    hashes = []
    highest = ('day-time', 0)
    for day in d.keys():
        for time in d[day].keys():
            price = d[day][time] = gen_price()
            hashes.append(hash(secret + "-".join([day, time, str(price)]).encode()))
            if price > highest[1]:
                highest = ("-".join([day, time]), price)
    return secret.hex(), " ".join(hashes), d, highest

def disp_prices(req, d, s):
    req.sendall(f"\nThe secret was {s}.\n".encode())
    for day in d.keys():
        for time in d[day].keys():
            req.sendall(f"{day.capitalize()} {time.upper()}: {d[day][time]}\n".encode())

def challenge(req):
    for n in range(20):
        secret, hashes, prices, highest = gen_hashes_and_prices()
        req.sendall(f"Price commitments for the week: {hashes}\n\n".encode())
        req.sendall(f"Monday AM Price: {prices['mon']['am']}\n".encode())
        req.sendall(f"(Week {n+1}) Enter day-time of highest price for the week: ".encode())
        inp = req.recv(256).strip().decode().lower()
        if inp != highest[0]:
            disp_prices(req, prices, secret)
            req.sendall(b"Try again next week.\n")
            exit(0)
        req.sendall(b'You got it!\n')
    else:
        req.sendall(f"Even Tom Nook is impressed. Here's your flag: {FLAG.decode()}".encode())
        exit(0)

class TaskHandler(socketserver.BaseRequestHandler):
    def handle(self):
        self.request.sendall(BANNER)
        self.request.sendall(MESSAGE)
        challenge(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 8080), TaskHandler)
    server.serve_forever()
```

##### Solution

I started reading it and noticed a few things which scarred me `sbox` and
`hash`. `sbox` from what I remembered had something to do with cryptography and
[searching online](https://en.wikipedia.org/wiki/S-box) confirmed it.

I then started reading from where code was executed (skip the function
definitions).

```python
class TaskHandler(socketserver.BaseRequestHandler):
    def handle(self):
        self.request.sendall(BANNER)
        self.request.sendall(MESSAGE)
        challenge(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 8080), TaskHandler)
    server.serve_forever()
```

Is used to serve the challenge and seems unrelated to the problem. The `handle`
function sends the banner and a message and then calls the `challenge` function
which is where the core of the challenge seems to be located.

```python
    for n in range(20):
        secret, hashes, prices, highest = gen_hashes_and_prices()
        req.sendall(f"Price commitments for the week: {hashes}\n\n".encode())
        req.sendall(f"Monday AM Price: {prices['mon']['am']}\n".encode())
        req.sendall(f"(Week {n+1}) Enter day-time of highest price for the week: ".encode())
        inp = req.recv(256).strip().decode().lower()
        if inp != highest[0]:
            disp_prices(req, prices, secret)
            req.sendall(b"Try again next week.\n")
            exit(0)
        req.sendall(b'You got it!\n')
    else:
        req.sendall(f"Even Tom Nook is impressed. Here's your flag: {FLAG.decode()}".encode())
        exit(0)
```

The flag is sent in the else block which is reached when the for loop finishes
without being exited (with a `break` or like in this case with `exit`). This
means we must have `inp == highest[0]` 20 times consecutively. Each time
represents a "week".

We are given all hashes, the price on Monday at time "am" and are asked to enter
the time of the highest price in the week. All of these values are retrieved
from the function `gen_hashes_and_prices`.

```python
def gen_hashes_and_prices():
    d = {"mon": {"am": 0, "pm": 0},"tue": {"am": 0, "pm": 0},"wed": {"am": 0, "pm": 0},"thu": {"am": 0, "pm": 0},"fri": {"am": 0, "pm": 0},"sat": {"am": 0, "pm": 0}}
    secret = bytearray(urandom(16))
    seed(int.from_bytes(secret, 'big'))
    hashes = []
    highest = ('day-time', 0)
    for day in d.keys():
        for time in d[day].keys():
            price = d[day][time] = gen_price()
            hashes.append(hash(secret + "-".join([day, time, str(price)]).encode()))
            if price > highest[1]:
                highest = ("-".join([day, time]), price)
    return secret.hex(), " ".join(hashes), d, highest
```

The function `gen_hashes_and_prices` generates a `secret` using the function
`urandom()` from the module `os`. I assumed this function to generate
cryptographically random numbers (we can't guess the numbers it will generate
from previous numbers it generated) as I know `/dev/urandom` to be secure, and
in fact [the
documentation](https://docs.python.org/3/library/os.html#os.urandom) for it
confirms this is the case. It then sets the seed used by the python `random`
module, which means that if we know the value of `secret` we can possibly get
all the numbers generated, additionally the `random` module isn't
cryptographically secure which means that with enough numbers generated by it,
we can guess the next numbers.

The function then iterates over the days in the week from Monday to Saturday
(excluding Sunday), and for each iterates over the times "am" and "pm". For each
times (combination of day and time), it generates a price using the `gen_price`
function and then appends to the list `hashes`, the value returned by the
function `hash`, with as input a string made-up of the secret and the day of the
week, time and price. If the price generated is the highest seen so far,
`highest` is updated.

The `gen_price` function generates a price based on 2 calls to `randint`. This
means that knowing the price of Monday at time "am", means that we have one of
the number generated and an estimation of another one. Because the seed used by
the random function is updated each "week", it means that each "week" is
independent and we can't use data from previous weeks to solve the following
weeks.

I searched online to find how to predict numbers from the `random` module. I
found [a
post](https://crypto.stackexchange.com/questions/53811/is-it-possible-to-recover-the-seed-used-by-pythons-pseudo-random-number-generat)
the discusses it. However, the answers says that even with 40 generated numbers
it is not possible to reverse the state of the number generator. Considering
that for each week, only 24 numbers (2 per generated price, for 2 times for 6
days per week) are generated, it means that exploiting the `random` module seems
out of reach.

Next I looked at the `hash` function. It starts with an initial state and then
for each group of 16 bytes in the data, changes the state based on it.

At this point I was lost and didn't know what to do. A teammate, Uzay, who was
also looking at the challenge said that he managed to run it locally, and that
it allowed to print some stuff. I followed his suggestion and added a print
statement that prints the `state` in the `hash` function for each block of 16
bytes:

```python
    data = group(pad(data))
    for roundkey in data:
        print(state)
        for _ in range(round):
```

A file named `secret.py` with the following line also had to be added so that
the program could run:

```python
FLAG="testing_flag"
```

Once running this is what was printed on the server.py output when a client
connected:

```
$ python server.py
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
bytearray(b'\xa5Dr\xe4\x97\x92j\xee\xc6\xf1\xc6z.\x94\x03&')
bytearray(b'\xcb\xc5\xd7\x04?\x96)\xe9#r\xd1\x92\xd7*\x18u')
```

For each time in the day, the state was the same. This is because the data is
processed in blocks of 16 bytes, and the first 16 bytes are the secret which is
the same for each day of the week. (Also note that in the output, every other
line is just the inital state). This means that if we were able to determine the
state after the first block was processed, we could brute force the different
possible prices and find the one that matched the hash we get from the server,
by manually performing the processing of the second block. My initial thought
was that maybe we could use some kind of "simultaneously" equation to determine
that state and decided to look at the `hash` function, to see whether that was
possible.

```python
def pad(s):
    if len(s) % 16 == 0:
        return s
    else:
        pad_b = 16 - len(s) % 16
        return s + bytes([pad_b]) * pad_b

def repeated_xor(p, k):
    return bytearray([p[i] ^ k[i] for i in range(len(p))])

def group(s):
    return [s[i * 16: (i + 1) * 16] for i in range(len(s) // 16)]

def hash(data):
    state = bytearray([165, 68, 114, 228, 151, 146, 106, 238, 198, 241, 198, 122, 46, 148, 3, 38])
    data = group(pad(data))
    for roundkey in data:
        for _ in range(round):
            state = repeated_xor(state, roundkey)
            for i in range(len(state)):
                state[i] = sbox[state[i]]
            temp = bytearray(16)
            for i in range(len(state)):
                temp[p[i]] = state[i]
            state = temp
    return state.hex()
```

Looking at the hash function in reverse, I noticed that the last 2 operations of
each round were reversible, they just 1. changed the order of the bytes 2.
changed the bytes using the Sbox which is also reversible. The only part that
isn't reversible is the `repeated_xor` operation which just XORs together its 2
parameters, the roundkey (i.e. a 16 bytes block of input data), and the current
state. This meant that in order to reverse it, we needed the input data which
was already what we were trying to get. This is when I realised we were given
the price on Monday at the "am" time, which meant that we could actually reverse
the hash function until we reached the common state shared by all the hashes
(i.e. the state when the hash function has only processed the secret).

So I started to write a script to do this.

```python
#!/usr/bin/env python3

from pwn import *

sbox = [92, 74, 18, 190, 162, 125, 45, 159, 217, 153, 167, 179, 221, 151, 140, 100, 227, 83, 8, 4, 80, 75, 107, 85, 104, 216, 53, 90, 136, 133, 40, 20, 94, 32, 237, 103, 29, 175, 127, 172, 79, 5, 13, 177, 123, 128, 99, 203, 0, 198, 67, 117, 61, 152, 207, 220, 9, 232, 229, 120, 48, 246, 238, 210, 143, 7, 33, 87, 165, 111, 97, 135, 240, 113, 149, 105, 193, 130, 254, 234, 6, 76, 63, 19, 3, 206, 108, 251, 54, 102, 235, 126, 219, 228, 141, 72, 114, 161, 110, 252, 241, 231, 21, 226, 22, 194, 197, 145, 39, 192, 95, 245, 89, 91, 81, 189, 171, 122, 243, 225, 191, 78, 139, 148, 242, 43, 168, 38, 42, 112, 184, 37, 68, 244, 223, 124, 218, 101, 214, 58, 213, 34, 204, 66, 201, 180, 64, 144, 147, 255, 202, 199, 47, 196, 36, 188, 169, 186, 1, 224, 166, 10, 170, 195, 25, 71, 215, 52, 15, 142, 93, 178, 174, 182, 131, 248, 26, 14, 163, 11, 236, 205, 27, 119, 82, 70, 35, 23, 88, 154, 222, 239, 209, 208, 41, 212, 84, 176, 2, 134, 230, 51, 211, 106, 155, 185, 253, 247, 158, 56, 73, 118, 187, 250, 160, 55, 57, 16, 17, 157, 62, 65, 31, 181, 164, 121, 156, 77, 132, 200, 138, 69, 60, 50, 183, 59, 116, 28, 96, 115, 46, 24, 44, 98, 233, 137, 109, 49, 30, 173, 146, 150, 129, 12, 86, 249]
p = [8, 6, 5, 11, 14, 7, 4, 0, 9, 1, 13, 10, 2, 3, 15, 12]

def repeated_xor(p, k):
    return bytearray([p[i] ^ k[i] for i in range(len(p))])

def pad(s):
    if len(s) % 16 == 0:
        return s
    else:
        pad_b = 16 - len(s) % 16
        return s + bytes([pad_b]) * pad_b

round = 8
def unrounds(state_hash, roundkey):
    for _ in range(round):
        temp = bytearray(16)
        assert len(state_hash) == 16
        for i in range(len(state_hash)):
            temp[i] = state_hash[p[i]]
        state_hash = temp
        for i in range(len(state_hash)):
            state_hash[i] = sbox.index(state_hash[i])
        state_hash = repeated_xor(state_hash, roundkey)
    return state_hash

def hash(state, roundkey):
    roundkey = pad(roundkey)
    for _ in range(round):
        state = repeated_xor(state, roundkey)
        for i in range(len(state)):
            state[i] = sbox[state[i]]
        temp = bytearray(16)
        for i in range(len(state)):
            temp[p[i]] = state[i]
        state = temp
    return state.hex()

def find_highest(hashes, state):
    d = {"mon": {"am": 0, "pm": 0},"tue": {"am": 0, "pm": 0},"wed": {"am": 0, "pm": 0},"thu": {"am": 0, "pm": 0},"fri": {"am": 0, "pm": 0},"sat": {"am": 0, "pm": 0}}
    highest = ('day-time', 0)
    i = 0
    for day in d.keys():
        for time in d[day].keys():
            for price in range(highest[1], 601):
                hash_temp = hash(state, "-".join([day, time, str(price)]).encode())
                if hashes[i] == hash_temp:
                    highest = ("-".join([day, time]), price)
            i += 1
    return highest[0]

if __name__ == "__main__":
    r = remote('chals20.cybercastors.com', 14423)
    #r = remote('127.0.0.1', 8080)

    r.recvuntil("Ultimate Turnip Prophet!\n\n")

    for x in range(20):
        lines = r.recvuntil('price for the week: ').split(b'\n')
        hashes = list(map(lambda x: x.decode(), lines[0].split()[5:]))
        mon_am_price = lines[2].split()[3].decode()
        roundkey = pad("-".join(["mon", "am", mon_am_price]).encode())
        state = unrounds(bytearray.fromhex(hashes[0]), roundkey)
        correct = find_highest(hashes, state)
        print(correct)
        r.sendline(correct)
        r.recvuntil("!\n")
    r.interactive()
```

The `unrounds` function does the same thing as is done for each block in the
`hash` function of `server.py`, except it does it in reverse. This allows us to
retrieve the state that is common to all hashes. Then in the `find_highest`
function, I go through each time in each day (combination of day of week and
"am" or "pm"), and find by brute forcing which price is correct and get the
highest correct value. Once this is done, `find_highest` returns with the time
at which the price is highest and sends it to the server.

```
$ ./client.py
[+] Opening connection to chals20.cybercastors.com on port 14423: Done
sat-am
thu-am
fri-am
wed-pm
sat-am
thu-am
mon-am
mon-am
sat-am
sat-pm
fri-pm
sat-am
tue-am
tue-pm
tue-pm
sat-pm
thu-am
sat-pm
wed-am
wed-am
[*] Switching to interactive mode
Even Tom Nook is impressed. Here's your flag: castorsCTF{y0u_4r3_7h3_u1t1m4t3_turn1p_pr0ph37}[*] Got EOF while reading in interactive
$
$
[*] Closed connection to chals20.cybercastors.com port 14423
[*] Got EOF while sending in interactive
```

##### Flag

```
castorsCTF{y0u_4r3_7h3_u1t1m4t3_turn1p_pr0ph37}
```

#### One Trick Pony (236 pts 116 solves)

##### Description

```
Author: hasu
nc chals20.cybercastors.com 14422
```

##### Solution

When you connect to the endpoint given, you get a prompt and when you type
something, you get what looks like a C-string literal (It's actually just a
python byte string but I didn't notice that when I first solved the challenge)
of the same length as your input.

```
$ nc chals20.cybercastors.com 14422
> please give me feedback
b'\x13\r\x16\x15\x1c\x17S$=0\x1eK^VP9\x1cU\x11\x10>\x08X'
> aaaa
b'\x02\x12\x15'
> ^C
```

The name of the challenge "One Trick Pony", made me think of [one-time
pads](https://en.wikipedia.org/wiki/One-time_pad), so I thought of XOR-ing my
input with the output we're given:

```
$ nc chals20.cybercastors.com 14422
> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
b'\x02\x12\x15\x0e\x13\x12"5\'\x1a\nRR\x11>\x18Q\x14\x13>\nR\x18T>TR\x02\x13RV>U\x0f\x05>\x05Q\x0fV>\x13R\x14TR>V\tR\x0c@\x1c\x02\x12\x15\x0e\x13\x12"5\'\x1a\nRR\x11>\x18Q\x14\x13>\nR\x18T>TR\x02\x13RV>U\x0f\x05>\x05Q\x0fV>\x13R\x14TR>V\tR\x0c@\x1c\x02\x12\x15\x0e\x13\x12"5\'\x1a\nRR\x11>\x18Q\x14\x13>\nR\x18T>TR\x02\x13RV>U\x0f\x05>\x05Q\x0fV>\x13R\x14TR>V\tR\x0c@\x1c\x02'
> ^C
```

As I hadn't noticed it was a byte string and I'm generally prefer to use C for
byte manipulation I wrote a "script in C":

```c
#include <stdio.h>

int main() {

	char a[] = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
	char b[] = "\x02\x12\x15\x0e\x13\x12\"5\'\x1a\nRR\x11>\x18Q\x14\x13>\nR\x18T>TR\x02\x13RV>U\x0f\x05>\x05Q\x0fV>\x13R\x14TR>V\tR\x0c@\x1c\x02\x12\x15\x0e\x13\x12\"5\'\x1a\nRR\x11>\x18Q\x14\x13>\nR\x18T>TR\x02\x13RV>U\x0f\x05>\x05Q\x0fV>\x13R\x14TR>V\tR\x0c@\x1c\x02\x12\x15\x0e\x13\x12\"5\'\x1a\nRR\x11>\x18Q\x14\x13>\nR\x18T>TR\x02\x13RV>U\x0f\x05>\x05Q\x0fV>\x13R\x14TR>V\tR\x0c@\x1c\x02";
	for (int i = 0; i < 168; ++i) {
		putchar(a[i] ^ b[i]);
	}
}
```

```
$ gcc one.c
$ ./a.out
cstorsCTF{k33p_y0ur_k3y5_53cr37_4nd_d0n7_r3u53_7h3m!}cstorsCTF{k33p_y0ur_k3y5_53cr37_4nd_d0n7_r3u53_7h3m!}cstorsCTF{k33p_y0ur_k3y5_53cr37_4nd_d0n7_r3u53_7h3m!}caaaa
```

##### Flag

```
cstorsCTF{k33p_y0ur_k3y5_53cr37_4nd_d0n7_r3u53_7h3m!}
```

### Reversing

I really appreciated the reversing challenges especially the GO(lang) ones as I
had never done go reverse engineering and I learned a lot.

#### Stacking (50 pts 208 solves)

##### Description

[`stacking`](/assets/files/castorsCTF20/stacking)

##### Solution

<video controls="true">
	<source src="/assets/files/castorsCTF20/stacking.mp4">
</video>

##### Flag

```
castorsCTF{w3lc0m3_70_r3v3r53_3n61n33r1n6}
```

#### XoR (74 points 147 solves)

##### Description

[`xorry`](/assets/files/castorsCTF20/xorry)

##### Solution

<video controls="true">
	<source src="/assets/files/castorsCTF20/xor.mp4">
</video>

##### Flag

```
castorsCTF{x0rr1n6_w17h_4_7w157}
```
